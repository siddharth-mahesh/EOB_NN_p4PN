# hnn_class.py
"""
A Hamiltonian Neural Network (HNN) model for static and stationary geodesics.
The module generates training waveforms by integrating geodesics in a Schwarzschild-like geometry
with the metric potential A(r) (= 1 - 2M/r for Schwarzschild) generated by a Neural Network.
"""

import jax
import jax.numpy as jnp

# set jax to 64 bit precision
jax.config.update("jax_enable_x64", True)
import equinox as eqx
from EOB_NN_p4PN.mlp import MLP

class HNN_Model(eqx.Module):
    lin_1: eqx.nn.Linear
    lin_2: eqx.nn.Linear
    lin_3: eqx.nn.Linear
    """
    A Hamiltonian Neural Network model that learns a component of the Hamiltonian.
    The model's forward pass computes the corresponding waveform amplitude.
    """
    def __init__(self, key, hidden_dim=50, input_dim = "scalar"):
        """
        Initialize the HNN.

        Args:
            key (jax.random.PRNGKey): The random key for initialization.
            hidden_dim (int): The dimension of the hidden layers.
            input_dim (int): The dimension of the input space for the potential net.
        """
        key1, key2, key3 = jax.random.split(key, 3)
        self.lin_1 = eqx.nn.Linear(input_dim, hidden_dim, key=key1,use_bias=False)
        self.lin_2 = eqx.nn.Linear(hidden_dim, hidden_dim, key=key2,use_bias=False)
        self.lin_3 = eqx.nn.Linear(hidden_dim, 1, key=key3,use_bias=False)
    
    def _get_h(self, y):
        """
        Compute the Hamiltonian.

        Args:
            y (jnp.ndarray): State vector [r, phi, p_r, p_phi].
            
        Returns:
            jnp.ndarray: The Hamiltonian component.
        """
        r , _ , p_r , p_phi = y
        a_potential = self.lin_3(
            jnp.tanh(
                self.lin_2(
                    jnp.tanh(
                        self.lin_1(r)
                    )
                )
            )
        )
        energy_sq = a_potential * (1 + a_potential * p_r**2 + p_phi**2 / r**2)
        energy = jnp.sqrt(energy_sq)
        return energy.squeeze()
    
    def _dynamics(self, y):
        """
        Compute the time derivatives using the learned Hamiltonian component.

        Args:
            y (jnp.ndarray): State vector [r, phi, p_r, p_phi].
            
        Returns:
            jnp.ndarray: The time derivatives [dr/dt, dphi/dt, dp_r/dt, dp_phi/dt].
        """
        num_coords = y.shape[0] // 2
        symplectic_map = jnp.block(
            [
                [jnp.zeros((num_coords, num_coords)), jnp.eye(num_coords)],
                [-jnp.eye(num_coords), jnp.zeros((num_coords, num_coords))],
            ]
        )
        dH = jax.grad(self._get_h, argnums=0)(y)
        return symplectic_map @ dH

    def _calculate_strain(self, z):
        """
        Calculate the complex strain from the state and its derivatives.

        Args:
            z (jnp.ndarray): The input vector [r, phi, p_r, p_phi].
            
        Returns:
            jnp.complex128: The complex strain h22.
        """

        # Split the state vector into position and momentum
        r , phi , p_r , p_phi = z
        y = jnp.array([r, phi, p_r, p_phi])
        rdot , phidot  , _ , _ = self._dynamics(y)
        # compute the leading order strain amplitude
        real_part = 1 / r + r**2 * phidot**2 - rdot**2
        H_22 = real_part
        
        # Calculate the complex strain h22
        h22 = 4 * H_22 * jnp.exp(-2.0 * 1j * phi)
        return jnp.abs(h22)
    
    def __call__(self, zs):
        """
        Define the forward pass to compute the waveform from a state vector y.
        The model returns the amplitude of the waveform.
        
        Args:
            y (jnp.ndarray): batch of input vectors [r, phi, p_r, p_phi].
            
        Returns:
            jnp.ndarray: The amplitudes of the waveform.
        """
        return jax.vmap(self._calculate_strain, in_axes=0)(zs)

if __name__ == "__main__":
    key = jax.random.PRNGKey(42)
    hnn = HNN_Model(key)
    y_key = jax.random.PRNGKey(24)
    ys = jax.random.uniform(y_key, (100, 4), minval=7.0, maxval=10.0)
    zs = ys
    print(zs)
    h22 = hnn(zs)
    print(h22)
    